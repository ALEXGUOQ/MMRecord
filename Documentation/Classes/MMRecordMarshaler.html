<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>MMRecordMarshaler Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<meta name="viewport" content="width=550" />
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.0.5 (build 789)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">MMRecord </a></h1>
				<a id="developerHome" href="../index.html">Mutual Mobile</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">MMRecordMarshaler Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:">&nbsp;&nbsp;&nbsp;&nbsp;+ establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:</option>
	
	<option value="//api/name/establishRelationship:fromRecord:toRecord:">&nbsp;&nbsp;&nbsp;&nbsp;+ establishRelationship:fromRecord:toRecord:</option>
	
	<option value="//api/name/establishRelationshipsOnProtoRecord:">&nbsp;&nbsp;&nbsp;&nbsp;+ establishRelationshipsOnProtoRecord:</option>
	
	<option value="//api/name/mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:">&nbsp;&nbsp;&nbsp;&nbsp;+ mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:</option>
	
	<option value="//api/name/populateProtoRecord:">&nbsp;&nbsp;&nbsp;&nbsp;+ populateProtoRecord:</option>
	
	<option value="//api/name/populateProtoRecord:attributeDescription:fromDictionary:">&nbsp;&nbsp;&nbsp;&nbsp;+ populateProtoRecord:attributeDescription:fromDictionary:</option>
	
	<option value="//api/name/setValue:onRecord:attribute:dateFormatter:">&nbsp;&nbsp;&nbsp;&nbsp;+ setValue:onRecord:attribute:dateFormatter:</option>
	
	<option value="//api/name/valueForAttribute:rawValue:dateFormatter:">&nbsp;&nbsp;&nbsp;&nbsp;+ valueForAttribute:rawValue:dateFormatter:</option>
	
	
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Public Interface Methods">Public Interface Methods</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Public Subclassing Methods">Public Subclassing Methods</a></span></li>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:">establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/establishRelationship:fromRecord:toRecord:">establishRelationship:fromRecord:toRecord:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/establishRelationshipsOnProtoRecord:">establishRelationshipsOnProtoRecord:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:">mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/populateProtoRecord:">populateProtoRecord:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/populateProtoRecord:attributeDescription:fromDictionary:">populateProtoRecord:attributeDescription:fromDictionary:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setValue:onRecord:attribute:dateFormatter:">setValue:onRecord:attribute:dateFormatter:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/valueForAttribute:rawValue:dateFormatter:">valueForAttribute:rawValue:dateFormatter:</a></span></li>
	
</ul></li>




			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="MMRecordMarshaler Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">MMRecordMarshaler Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">MMRecordMarshaler.h<br />MMRecordMarshaler.m</td>
</tr>
						</tbody></table></div>
					
					
					
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>This class is the main sheriff in town for populating an instance of <a href="../Classes/MMRecord.html">MMRecord</a>. This class holds
no state but takes as parameters the proto records which hold all of the information necesary to
populate the record that they hold. This class is meant to be subclassed, although this is the base
implementation of the marshaler. The class that will be used to marshal a record of a given type of
entity is defined in the <a href="../Classes/MMRecordRepresentation.html"><code>MMRecordRepresentation</code></a>. In that sense, the marshaler is somewhat tied to
the representation. This allows the user even more flexibility in their representations such that
they can actually change the population mechanism used for individual entities in <a href="../Classes/MMRecord.html">MMRecord</a>.</p>

<h2>Default Implementation</h2>

<p>The default implementation of the marshaler populates all attributes on the given proto record&rsquo;s
instance of <a href="../Classes/MMRecord.html">MMRecord</a> as defined by that proto record&rsquo;s representation. The marshal will ask the
representation for the list of attributes, and attempt to populate all of them using the
+populateProtoRecord:attributeDescription:fromDictionary method. By default, that method will call
the +setValue method for the attribute using the first valid key which obtains a value from the
dictionary.</p>

<p>The default implementation of the marshaler will also establish each relationship as similarly
defined by the proto record&rsquo;s representation.</p>

<h2>Subclassing Notes</h2>

<p>A good reason to subclass the marshaler would be to change the way population events occur in
<a href="../Classes/MMRecord.html">MMRecord</a>. For example, if you wanted to change the behavior for how numbers and strings are
populated, you could create a custom marshaler. If you wanted the ability to create more
specialized date population, you could create a custom marshaler. If you want to change how
transformable attributes are populated, or perhaps add support for storing the entire dictionary or
a different value entirely in an attribute, then creating a custom marshaler through subclassing is
definitely a route you should explore.</p>

<p>Another option for subclassing is to subclass to provide an extension of functionality rather than
different functionality. For example, you may choose to conditionally establish a relationship
based on certain logic, like the existence or value of some fields. Or you may want to delete
certain relationships or remove existing objects from a to-many relationship as part of the
population process. Subclassing the marshaler gives you the flexibility to do that. In effect,
it allows you to build in pre-post process hooks into the population process. This is very powerful.</p>

<h2>Subclassing Instructions</h2>

<p>While a user wishing to subclass the marshal may override any method they choose, the three methods
at the bottom may make the most sense to override in a subclass. These methods are called
internally by the marshaler itself to actually perform the actions described above. The top three
methods are intended to be the public interface of the <code>MMRecordMarshaler</code> class, and though they
can be overriden, are not necesarily recommended to be changed.</p>
					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						<a title="Public Interface Methods" name="task_Public Interface Methods"></a>
						<h3 class="subsubtitle task-title">Public Interface Methods</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/populateProtoRecord:">+&nbsp;populateProtoRecord:</a></code>
		<span class="tooltip"><p>This method initiates the attribute population process for the given proto record. It will iterate
through the attributes provided by the proto record&rsquo;s representation and attempt to populate each
one.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/establishRelationshipsOnProtoRecord:">+&nbsp;establishRelationshipsOnProtoRecord:</a></code>
		<span class="tooltip"><p>This method initiates the process of establishing relationships to all of the relationship protos
for the given proto record. It will iterate through the relationship protos associated to the proto
record and attempt to establish a relationship with each of them.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:">+&nbsp;establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:</a></code>
		<span class="tooltip"><p>This method is used when the given proto record uses a relationship as it&rsquo;s primary means of
identification. It will establish the primary relationship to the given primary key proto record.
The relationship primary key proto record should be associated with a parent object of the proto
record&rsquo;s instance of <a href="../Classes/MMRecord.html"><code>MMRecord</code></a>.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:">+&nbsp;mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:</a></code>
		<span class="tooltip"><p>This method is used when a response contains multiple instances of the same record. <a href="../Classes/MMRecord.html">MMRecord</a> will
always do its best to create and populate these records and associate them with the appropriate
relationships on various other records. Generally speaking, its expected that a response will
contain either duplicate references to record primary keys, which allow <a href="../Classes/MMRecord.html">MMRecord</a> to fetch the
appropriate record to associate as a relationship. Or, the response may contain duplicate fully
saturated objects. In this case, the first fully saturated object will &ldquo;win&rdquo;, and all other
references to that object will be populated using the first one that is found.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Public Subclassing Methods" name="task_Public Subclassing Methods"></a>
						<h3 class="subsubtitle task-title">Public Subclassing Methods</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/populateProtoRecord:attributeDescription:fromDictionary:">+&nbsp;populateProtoRecord:attributeDescription:fromDictionary:</a></code>
		<span class="tooltip"><p>This method is designed to be subclassed. It should be called to handle the population of a
specific attribute from a given dictionary for a particular record on the given proto record.
The basic implementation of this will call +setValue: with a value obtained from the given
dictionary based on possible key paths from the proto&rsquo;s representation. However, a subclass may
want to provide custom behavior, which is what this method is intended to be used for.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setValue:onRecord:attribute:dateFormatter:">+&nbsp;setValue:onRecord:attribute:dateFormatter:</a></code>
		<span class="tooltip"><p>This method is designed to be subclassed. It should be used to set the value of an attribute on an
instance of <a href="../Classes/MMRecord.html">MMRecord</a>. The value should be predetermined by another method. By default this is done
in the <a href="#//api/name/populateProtoRecord:">populateProtoRecord:</a> method defined above. The attribute is used to provide the type that
the attribute represents. Population of different types is handled in different ways. Overriding
this method allows you to change how different types of attributes are populated.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/valueForAttribute:rawValue:dateFormatter:">+&nbsp;valueForAttribute:rawValue:dateFormatter:</a></code>
		<span class="tooltip"><p>This method is designed to be subclassed. It is used to supply the properly formatted value for the
setValue: method above. The term &ldquo;formatted&rdquo; can mean different things for different types of
attributes. For date attributes that may mean applying a date formatter, or for transformed
attributes applying a value transformer. Or it may mean something entirely different based on the
needs of your application. Thats why its a public method &ndash; to allow you to subclass and provide
custom behavior as necessary.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/establishRelationship:fromRecord:toRecord:">+&nbsp;establishRelationship:fromRecord:toRecord:</a></code>
		<span class="tooltip"><p>This method is designed to be subclassed. It should be used to establish a given relationship from
one record to another. Subclassing this method allows you to change the means by which a
relationship is established, and possibly inject other logic to come before or after the
establishment of that relationship.</p></span>
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:" title="establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:"></a>
	<h3 class="subsubtitle method-title">establishPrimaryKeyRelationshipFromProtoRecord:toParentRelationshipPrimaryKeyProtoRecord:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is used when the given proto record uses a relationship as it&rsquo;s primary means of
identification. It will establish the primary relationship to the given primary key proto record.
The relationship primary key proto record should be associated with a parent object of the proto
record&rsquo;s instance of <a href="../Classes/MMRecord.html"><code>MMRecord</code></a>.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (void)establishPrimaryKeyRelationshipFromProtoRecord:(MMRecordProtoRecord *)<em>protoRecord</em> toParentRelationshipPrimaryKeyProtoRecord:(MMRecordProtoRecord *)<em>parentRelationshipPrimaryKeyProto</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>protoRecord</em></dt>
			<dd><p>The proto record which we want to establish a primary key relationship for.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>parentRelationshipPrimaryKeyProto</em></dt>
			<dd><p>The proto record that represents both the primary key
proto for the given proto record, as well as a parent object to the given proto record.
@discussion For more about primary key relationships, please see the header file for <a href="../Classes/MMRecord.html"><code>MMRecord</code></a>.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is used when the given proto record uses a relationship as it&rsquo;s primary means of
identification. It will establish the primary relationship to the given primary key proto record.
The relationship primary key proto record should be associated with a parent object of the proto
record&rsquo;s instance of <a href="../Classes/MMRecord.html"><code>MMRecord</code></a>.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/establishRelationship:fromRecord:toRecord:" title="establishRelationship:fromRecord:toRecord:"></a>
	<h3 class="subsubtitle method-title">establishRelationship:fromRecord:toRecord:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is designed to be subclassed. It should be used to establish a given relationship from
one record to another. Subclassing this method allows you to change the means by which a
relationship is established, and possibly inject other logic to come before or after the
establishment of that relationship.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (void)establishRelationship:(NSRelationshipDescription *)<em>relationship</em> fromRecord:(MMRecord *)<em>fromRecord</em> toRecord:(MMRecord *)<em>toRecord</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>relationship</em></dt>
			<dd><p>The relationship to be established.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>fromRecord</em></dt>
			<dd><p>The first record, to establish the relationship from.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>toRecord</em></dt>
			<dd><p>The second record, to establish the relationship to.
@discussion Basically this does exactly what you think based on how it reads.
Establish a relationship from one record to another.
@discussion This method has a lot of potential for subclassing. It allows you to do things like
conditionally set relationships based on property values elsewhere in the record, or to clear out
fields based on other parameters. Overall, this is extremely powerful. Use this wisely.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is designed to be subclassed. It should be used to establish a given relationship from
one record to another. Subclassing this method allows you to change the means by which a
relationship is established, and possibly inject other logic to come before or after the
establishment of that relationship.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/establishRelationshipsOnProtoRecord:" title="establishRelationshipsOnProtoRecord:"></a>
	<h3 class="subsubtitle method-title">establishRelationshipsOnProtoRecord:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method initiates the process of establishing relationships to all of the relationship protos
for the given proto record. It will iterate through the relationship protos associated to the proto
record and attempt to establish a relationship with each of them.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (void)establishRelationshipsOnProtoRecord:(MMRecordProtoRecord *)<em>protoRecord</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>protoRecord</em></dt>
			<dd><p>The proto record whose relationships we wish to establish.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method initiates the process of establishing relationships to all of the relationship protos
for the given proto record. It will iterate through the relationship protos associated to the proto
record and attempt to establish a relationship with each of them.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:" title="mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:"></a>
	<h3 class="subsubtitle method-title">mergeDuplicateRecordResponseObjectDictionary:withExistingProtoRecord:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is used when a response contains multiple instances of the same record. <a href="../Classes/MMRecord.html">MMRecord</a> will
always do its best to create and populate these records and associate them with the appropriate
relationships on various other records. Generally speaking, its expected that a response will
contain either duplicate references to record primary keys, which allow <a href="../Classes/MMRecord.html">MMRecord</a> to fetch the
appropriate record to associate as a relationship. Or, the response may contain duplicate fully
saturated objects. In this case, the first fully saturated object will &ldquo;win&rdquo;, and all other
references to that object will be populated using the first one that is found.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (void)mergeDuplicateRecordResponseObjectDictionary:(NSDictionary *)<em>dictionary</em> withExistingProtoRecord:(MMRecordProtoRecord *)<em>protoRecord</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>dictionary</em></dt>
			<dd><p>The dictionary for the n+1th record response object of a given type and
primary key.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>protoRecord</em></dt>
			<dd><p>The proto record created to represent this specific object by <a href="../Classes/MMRecord.html">MMRecord</a>.
@discussion The default implementation of this method will look for cases where a given record is
only identified by a primary key and includes no additional data to populate it with. In this case
the primary key of that original proto record will be compared with the incoming object dictionary
and if they match then the new dictionary will be associated with the proto record.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is used when a response contains multiple instances of the same record. <a href="../Classes/MMRecord.html">MMRecord</a> will
always do its best to create and populate these records and associate them with the appropriate
relationships on various other records. Generally speaking, its expected that a response will
contain either duplicate references to record primary keys, which allow <a href="../Classes/MMRecord.html">MMRecord</a> to fetch the
appropriate record to associate as a relationship. Or, the response may contain duplicate fully
saturated objects. In this case, the first fully saturated object will &ldquo;win&rdquo;, and all other
references to that object will be populated using the first one that is found.</p>

<p>This method is intended as a means to merge those various different response objects together to
create a master instance of a particular record. In some responses an object may contain a subset
of data in one place, and a larger subset of data in another place. In those instances, a user
may want for the larger subset to win, even if it wasn&rsquo;t found by <a href="../Classes/MMRecord.html">MMRecord</a> first.</p>

<p>You may override this method in a subclass of MMRecordMarshaler to provide this functionality.</p><div class="warning"><p><strong>Warning:</strong> If you decide to subclass this method you may want to use the super implementation
as a starting point for your own implementation. Calling super is not required, but is recommended.</p></div>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/populateProtoRecord:" title="populateProtoRecord:"></a>
	<h3 class="subsubtitle method-title">populateProtoRecord:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method initiates the attribute population process for the given proto record. It will iterate
through the attributes provided by the proto record&rsquo;s representation and attempt to populate each
one.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (void)populateProtoRecord:(MMRecordProtoRecord *)<em>protoRecord</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>protoRecord</em></dt>
			<dd><p>The proto record that we wish to populate.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method initiates the attribute population process for the given proto record. It will iterate
through the attributes provided by the proto record&rsquo;s representation and attempt to populate each
one.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/populateProtoRecord:attributeDescription:fromDictionary:" title="populateProtoRecord:attributeDescription:fromDictionary:"></a>
	<h3 class="subsubtitle method-title">populateProtoRecord:attributeDescription:fromDictionary:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is designed to be subclassed. It should be called to handle the population of a
specific attribute from a given dictionary for a particular record on the given proto record.
The basic implementation of this will call +setValue: with a value obtained from the given
dictionary based on possible key paths from the proto&rsquo;s representation. However, a subclass may
want to provide custom behavior, which is what this method is intended to be used for.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (void)populateProtoRecord:(MMRecordProtoRecord *)<em>protoRecord</em> attributeDescription:(NSAttributeDescription *)<em>attributeDescription</em> fromDictionary:(NSDictionary *)<em>dictionary</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>protoRecord</em></dt>
			<dd><p>The proto record that we wish to populate an attribute for.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>attributeDescription</em></dt>
			<dd><p>The attribute that we wish to populate.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>dictionary</em></dt>
			<dd><p>The set of values we have to choose from when populating this proto record.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is designed to be subclassed. It should be called to handle the population of a
specific attribute from a given dictionary for a particular record on the given proto record.
The basic implementation of this will call +setValue: with a value obtained from the given
dictionary based on possible key paths from the proto&rsquo;s representation. However, a subclass may
want to provide custom behavior, which is what this method is intended to be used for.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setValue:onRecord:attribute:dateFormatter:" title="setValue:onRecord:attribute:dateFormatter:"></a>
	<h3 class="subsubtitle method-title">setValue:onRecord:attribute:dateFormatter:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is designed to be subclassed. It should be used to set the value of an attribute on an
instance of <a href="../Classes/MMRecord.html">MMRecord</a>. The value should be predetermined by another method. By default this is done
in the <a href="#//api/name/populateProtoRecord:">populateProtoRecord:</a> method defined above. The attribute is used to provide the type that
the attribute represents. Population of different types is handled in different ways. Overriding
this method allows you to change how different types of attributes are populated.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (void)setValue:(id)<em>rawValue</em> onRecord:(MMRecord *)<em>record</em> attribute:(NSAttributeDescription *)<em>attribute</em> dateFormatter:(NSDateFormatter *)<em>dateFormatter</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>rawValue</em></dt>
			<dd><p>The RAW value to set on the record for the given attribute. This method may choose to
modify the raw value, depending on the type of attribute.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>record</em></dt>
			<dd><p>The record to set a value on.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>attribute</em></dt>
			<dd><p>The attribute to set a value for.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>dateFormatter</em></dt>
			<dd><p>The date formatter to use for populating a Date attribute.
@discussion The base implementation of this method supports all types of attributes, including date
and transformable. Populating a transformable attribute will invoke a NSValueTransformer subclass
as defined in the Core Data model.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is designed to be subclassed. It should be used to set the value of an attribute on an
instance of <a href="../Classes/MMRecord.html">MMRecord</a>. The value should be predetermined by another method. By default this is done
in the <a href="#//api/name/populateProtoRecord:">populateProtoRecord:</a> method defined above. The attribute is used to provide the type that
the attribute represents. Population of different types is handled in different ways. Overriding
this method allows you to change how different types of attributes are populated.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/valueForAttribute:rawValue:dateFormatter:" title="valueForAttribute:rawValue:dateFormatter:"></a>
	<h3 class="subsubtitle method-title">valueForAttribute:rawValue:dateFormatter:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is designed to be subclassed. It is used to supply the properly formatted value for the
setValue: method above. The term &ldquo;formatted&rdquo; can mean different things for different types of
attributes. For date attributes that may mean applying a date formatter, or for transformed
attributes applying a value transformer. Or it may mean something entirely different based on the
needs of your application. Thats why its a public method &ndash; to allow you to subclass and provide
custom behavior as necessary.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>+ (id)valueForAttribute:(NSAttributeDescription *)<em>attribute</em> rawValue:(id)<em>rawValue</em> dateFormatter:(NSDateFormatter *)<em>dateFormatter</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>attribute</em></dt>
			<dd><p>The attribute to return a formatted value for.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>rawValue</em></dt>
			<dd><p>The raw value as determined by the <a href="#//api/name/populateProtoRecord:">populateProtoRecord:</a> method for this record.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>dateFormatter</em></dt>
			<dd><p>The date formatter to use for formatting a Date attribute.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is designed to be subclassed. It is used to supply the properly formatted value for the
setValue: method above. The term &ldquo;formatted&rdquo; can mean different things for different types of
attributes. For date attributes that may mean applying a date formatter, or for transformed
attributes applying a value transformer. Or it may mean something entirely different based on the
needs of your application. Thats why its a public method &ndash; to allow you to subclass and provide
custom behavior as necessary.</p>

<p>A best practice when using this method is to treat the passed in raw value as the default. If you
have nothing to do to that value, then just return it directly. Generally speaking you will not
want to return nil from this method. The rawValue passed will never be nil.</p>

<p>Another best practice is to call super if you are only customizing the logic for one type of
attribute. Create a condition on that attribute type, and if its not met, simply return the result
of super&rsquo;s implementation.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MMRecordMarshaler.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2014 Mutual Mobile. All rights reserved. (Last updated: 2014-06-27)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.0.5 (build 789)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>